- [时间管理](#时间管理)
  - [相关介绍](#相关介绍)


# 时间管理

这一节主要讲一下，gstreamer跟时间相关的设施，比如：
* 怎么查询码流播放进度
* 如何跳转进度

## 相关介绍

`GstQuery`

用于向`element`或者`pad`查询音视频一些媒体信息，比如是否可以跳转进度

从前面的章节中我们的demo程序通常是`pipeline`跑起来后，只能等待错误返回或者文件播放完。这次我们修改一下，可以唤醒从而运行一些我们自定义的功能实现

示例:

```C++
#include <gst/gst.h>

static gboolean sg_terminal = FALSE;
static gboolean sg_is_playing = FALSE;
static gint64   sg_duration = GST_CLOCK_TIME_NONE;
GstElement* playbin = NULL;

static void handle_message(GstMessage* msg);

int main(int argc, char* argv[])
{

    gst_init(NULL, NULL);

    if((playbin = gst_element_factory_make("playbin", "pb")) == NULL)
    {
        g_print("can not find playbin\n");
        return 0;
    }

    g_object_set(playbin, "uri", "https://gstreamer.freedesktop.org/data/media/sintel_trailer-480p.webm", NULL);

    GstStateChangeReturn ret = gst_element_set_state(playbin, GST_STATE_PLAYING);

    if(ret == GST_STATE_CHANGE_FAILURE)
    {
        g_print("set state failed %d\n", ret);

        gst_object_unref(playbin);

        return 0;
    }

    GstBus* bus =  gst_element_get_bus(playbin);

    do{
        
        GstMessage* msg = gst_bus_timed_pop_filtered(bus, GST_MSECOND * 100, 
                                                    GST_MESSAGE_EOS           | GST_MESSAGE_ERROR   | 
                                                    GST_MESSAGE_STATE_CHANGED | GST_MESSAGE_DURATION);
        if(msg)
        {
            handle_message(msg);
        }
        else
        {
            if(sg_is_playing)
            {
                gint64 cur_pos = 0;

                if(!gst_element_query_position(playbin, GST_FORMAT_TIME, &cur_pos))
                {
                    g_print("can not query position\n");
                }

                if(!gst_element_query_duration(playbin, GST_FORMAT_TIME, &sg_duration))
                {
                    g_print("can not query duration\n");
                }

                g_print("position: %" GST_TIME_FORMAT "/ %" GST_TIME_FORMAT "\r", 
                        GST_TIME_ARGS(cur_pos), GST_TIME_ARGS(sg_duration));

            }

        }

    }while(!sg_terminal);

    gst_object_unref(bus);
    gst_object_unref(playbin);

}

static void handle_message(GstMessage* msg)
{
    switch(GST_MESSAGE_TYPE(msg))
    {
        case GST_MESSAGE_STATE_CHANGED:{

            GstState old_state, new_state, pending_state;

            gst_message_parse_state_changed(msg, &old_state, &new_state, &pending_state);

            if(GST_MESSAGE_SRC(msg) == GST_OBJECT(playbin))
            {
                g_print("stream state from %d to %d\n", old_state, new_state);

                sg_is_playing = new_state == GST_STATE_PLAYING;
            }

        }
    }
}
```

```C++
        GstMessage* msg = gst_bus_timed_pop_filtered(bus, GST_MSECOND * 100, 
                                                    GST_MESSAGE_EOS           | GST_MESSAGE_ERROR   | 
                                                    GST_MESSAGE_STATE_CHANGED | GST_MESSAGE_DURATION);
```
* 这里是一个阻塞操作，类似`select()`，可以设置超时时间，设置过滤事件

```C++
if(GST_MESSAGE_SRC(msg) == GST_OBJECT(playbin))
{
    sg_is_playing = new_state == GST_STATE_PLAYING;
}
```

我们设置了播放后，考虑到播放动作的结果是一个耗时过程，播放状态不是马上返回的，所以要判断是否处于播放状态，只能从事件回调上来后才能获取


```C++
if(!gst_element_query_position(playbin, GST_FORMAT_TIME, &cur_pos))
{
    g_print("can not query position\n");
}

if(!gst_element_query_duration(playbin, GST_FORMAT_TIME, &sg_duration))
{
    g_print("can not query duration\n");
}
g_print("position: %" GST_TIME_FORMAT "/ %" GST_TIME_FORMAT "\r", 
        GST_TIME_ARGS(cur_pos), GST_TIME_ARGS(sg_duration));
```

* 如果当前处于播放状态后，我们就可以用`gst_element_query_position`获取进度, 用`gst_element_query_duration`获取总时长了
* `GST_TIME_FORMAT` 是一个方便打印时间信息的格式化字符串
* `GST_TIME_ARGS` 也是一个方便打印时间信息时变量类型转换的宏
* `GST_SECOND` 则是gstreamer自带的时间单位宏，单位为秒，也有毫秒 微妙等单位